import * as THREE from 'three';

const vectorFromPosition = (positions, i, size) => {
  const ix = size * i;
  const iy = size * i + 1;
  const iz = size * i + 2;

  const x = positions[ix];
  const y = positions[iy];
  const z = positions[iz];

  const vec = new THREE.Vector3(x, y, z);
  return vec;
};

export const computeSiblingVertices = (positions) => {
  const size = 3;
  const width = Math.sqrt(positions.length / size);
  const height = width;
  const length = width * height;

  const as = new Array(length);
  const cs = new Array(length);
  const bs = new Array(length);

  for (let row = 0; row < height; row++) {
    for (let col = 0; col < width; col++) {
      const i = row * height + col;
      const vB = vectorFromPosition(positions, i, size);
      bs[i] = vB;

      let nextCol = col + 1;
      if (nextCol >= width) {
        nextCol = col - 1;
      }
      const iA = row * height + nextCol;
      const vA = vectorFromPosition(positions, iA, size);
      as[i] = vA;

      let nextRow = row + 1;
      if (nextRow >= height) {
        nextRow = row - 1;
      }
      const iC = nextRow * height + col;
      const vC = vectorFromPosition(positions, iC, size);
      cs[i] = vC;
    }
  }

  return [as, cs, bs];
};

const input = [
  -0.5, 0.5, 0, -0.3571428656578064, 0.5, 0, -0.2142857164144516, 0.5, 0,
  -0.0714285746216774, 0.5, 0, 0.0714285746216774, 0.5, 0, 0.2142857164144516,
  0.5, 0, 0.3571428656578064, 0.5, 0, 0.5, 0.5, 0, -0.5, 0.3571428656578064, 0,
  -0.3571428656578064, 0.3571428656578064, 0, -0.2142857164144516,
  0.3571428656578064, 0, -0.0714285746216774, 0.3571428656578064, 0,
  0.0714285746216774, 0.3571428656578064, 0, 0.2142857164144516,
  0.3571428656578064, 0, 0.3571428656578064, 0.3571428656578064, 0, 0.5,
  0.3571428656578064, 0, -0.5, 0.2142857164144516, 0, -0.3571428656578064,
  0.2142857164144516, 0, -0.2142857164144516, 0.2142857164144516, 0,
  -0.0714285746216774, 0.2142857164144516, 0, 0.0714285746216774,
  0.2142857164144516, 0, 0.2142857164144516, 0.2142857164144516, 0,
  0.3571428656578064, 0.2142857164144516, 0, 0.5, 0.2142857164144516, 0, -0.5,
  0.0714285746216774, 0, -0.3571428656578064, 0.0714285746216774, 0,
  -0.2142857164144516, 0.0714285746216774, 0, -0.0714285746216774,
  0.0714285746216774, 0, 0.0714285746216774, 0.0714285746216774, 0,
  0.2142857164144516, 0.0714285746216774, 0, 0.3571428656578064,
  0.0714285746216774, 0, 0.5, 0.0714285746216774, 0, -0.5, -0.0714285746216774,
  0, -0.3571428656578064, -0.0714285746216774, 0, -0.2142857164144516,
  -0.0714285746216774, 0, -0.0714285746216774, -0.0714285746216774, 0,
  0.0714285746216774, -0.0714285746216774, 0, 0.2142857164144516,
  -0.0714285746216774, 0, 0.3571428656578064, -0.0714285746216774, 0, 0.5,
  -0.0714285746216774, 0, -0.5, -0.2142857164144516, 0, -0.3571428656578064,
  -0.2142857164144516, 0, -0.2142857164144516, -0.2142857164144516, 0,
  -0.0714285746216774, -0.2142857164144516, 0, 0.0714285746216774,
  -0.2142857164144516, 0, 0.2142857164144516, -0.2142857164144516, 0,
  0.3571428656578064, -0.2142857164144516, 0, 0.5, -0.2142857164144516, 0, -0.5,
  -0.3571428656578064, 0, -0.3571428656578064, -0.3571428656578064, 0,
  -0.2142857164144516, -0.3571428656578064, 0, -0.0714285746216774,
  -0.3571428656578064, 0, 0.0714285746216774, -0.3571428656578064, 0,
  0.2142857164144516, -0.3571428656578064, 0, 0.3571428656578064,
  -0.3571428656578064, 0, 0.5, -0.3571428656578064, 0, -0.5, -0.5, 0,
  -0.3571428656578064, -0.5, 0, -0.2142857164144516, -0.5, 0,
  -0.0714285746216774, -0.5, 0, 0.0714285746216774, -0.5, 0, 0.2142857164144516,
  -0.5, 0, 0.3571428656578064, -0.5, 0, 0.5, -0.5, 0,
]; //?

8 ** 2; //?

// const [as, cs, bs] = computeSiblingVertices(input);

// console.log(bs);
